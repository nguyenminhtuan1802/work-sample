#include "ScenarioUtils.h"
#include "RoadRunnerConversions.h"

// #include "ogr_core.h"
// #include "ogr_spatialref.h"

////////////////////////////////////////////////////////////////////////////////

namespace rrProtoGrpc {

////////////////////////////////////////////////////////////////////////////////
// This implementation is from code generated by Simulink Coder for the model:
// https://mathworks-my.sharepoint.com/:u:/p/liw/ESv-0Mofq59KvPaVwJLG0PkB6IYVVx1VAGyJAkl_z4uKKQ?e=FJvYcY
// The model compute the 3D transformation matrix from an ENU local tangent frame
// located at a specific { latitude, longitude, altitude } to a WGS84 ECEF frame.

glm::dmat4 mpProjectionUtil::GetLLA2ECEFTransform(double latitude, double longitude, double altitude) {
    glm::dmat4 transform;

    double ct;
    double lonNew_tmp;
    double st_idx_0;
    double st_idx_2;

    // Compute location of the origin in ECEF coordinates
    st_idx_2   = latitude * 3.1415926535897931 / 180.0;
    st_idx_0   = std::abs(st_idx_2);
    lonNew_tmp = longitude * 3.1415926535897931 / 180.0;
    if (st_idx_0 > 3.1415926535897931) {
        st_idx_2 = GetFloatingPointRemainder(st_idx_2 + 3.1415926535897931,
                                             6.2831853071795862) -
                   3.1415926535897931;
        st_idx_0 = std::abs(st_idx_2);
    }

    if (st_idx_0 > 1.5707963267948966) {
        lonNew_tmp += 3.1415926535897931;
        if (std::isnan(st_idx_2)) {
            st_idx_2 = (std::numeric_limits<double>::quiet_NaN());
        } else if (st_idx_2 < 0.0) {
            st_idx_2 = -1.0;
        } else {
            st_idx_2 = (st_idx_2 > 0.0);
        }

        st_idx_2 *= 1.5707963267948966 - (st_idx_0 - 1.5707963267948966);
    }

    if (std::abs(lonNew_tmp) > 3.1415926535897931) {
        lonNew_tmp = GetFloatingPointRemainder(lonNew_tmp, 6.2831853071795862);
        lonNew_tmp -= std::trunc(lonNew_tmp / 3.1415926535897931) *
                      6.2831853071795862;
    }

    st_idx_0 = std::sin(st_idx_2);

    // Assign origin location to the transformation matrix (column 4)
    transform[3].x = (6.378137E+6 / std::sqrt(1.0 - st_idx_0 * st_idx_0 *
                                                        0.0066943799901413165) +
                      altitude) *
                     std::cos(st_idx_2) * std::cos(lonNew_tmp);
    transform[3].y = (6.378137E+6 / std::sqrt(1.0 - std::sin(st_idx_2) *
                                                        std::sin(st_idx_2) * 0.0066943799901413165) +
                      altitude) *
                     std::cos(st_idx_2) * std::sin(lonNew_tmp);
    transform[3].z = (6.378137E+6 / std::sqrt(1.0 - std::sin(st_idx_2) * std::sin(st_idx_2) * 0.0066943799901413165) * 0.99330562000985867 + altitude) * st_idx_0;
    transform[3].w = 1.0;

    // Compute rotation of the RoadRunner coordinate system against ECEF
    st_idx_0   = (longitude + 90.0) * 3.1415926535897931 / 180.0;
    st_idx_2   = (90.0 - latitude) * 3.1415926535897931 / 180.0;
    lonNew_tmp = std::cos(st_idx_0);
    st_idx_0   = std::sin(st_idx_0);
    ct         = std::cos(st_idx_2);
    st_idx_2   = std::sin(st_idx_2);

    // Assign the rotation matrix to the transformation matrix (column 1 to 3)
    transform[0].x = lonNew_tmp;
    transform[1].x = 0.0 * st_idx_2 * lonNew_tmp - st_idx_0 * ct;
    transform[2].x = 0.0 * ct * lonNew_tmp + st_idx_0 * st_idx_2;

    transform[0].y = st_idx_0;
    transform[1].y = 0.0 * st_idx_2 * st_idx_0 + lonNew_tmp * ct;
    transform[2].y = 0.0 * ct * st_idx_0 - lonNew_tmp * st_idx_2;

    transform[0].z = -0.0;
    transform[1].z = st_idx_2;
    transform[2].z = ct;

    transform[0].w = 0.0;
    transform[1].w = 0.0;
    transform[2].w = 0.0;

    return transform;
}

////////////////////////////////////////////////////////////////////////////////
// This implementation is from code generated by Simulink Coder for the model:
// https://mathworks-my.sharepoint.com/:u:/p/liw/ESv-0Mofq59KvPaVwJLG0PkB6IYVVx1VAGyJAkl_z4uKKQ?e=FJvYcY
// The function computes the floating point remainder of u0/u1. On top of std::fmod,
// the function handles some edge cases of u0 and u1.

double mpProjectionUtil::GetFloatingPointRemainder(double u0, double u1) {
    double y;
    if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {
        y = (std::numeric_limits<double>::quiet_NaN());
    } else if (std::isinf(u1)) {
        y = u0;
    } else if ((u1 != 0.0) && (u1 != std::trunc(u1))) {
        double q;
        q = std::abs(u0 / u1);
        if (!(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q)) {
            y = 0.0 * u0;
        } else {
            y = std::fmod(u0, u1);
        }
    } else {
        y = std::fmod(u0, u1);
    }

    return y;
}

////////////////////////////////////////////////////////////////////////////////
// This implementation is from code generated by Simulink Coder for the model:
// https://mathworks-my.sharepoint.com/:f:/p/sjayadev/EgoCqwY6gkZGs_KA6AI23LYBP7bTPd3jXw6_NTakm89CbQ?e=ilFed0
// The model compute the { latitude, longitude, altitude } of a point based on the WGS84 datum
// from the ECEF coordinate of that point

double mpProjectionUtil::GetInverseTan(double u0, double u1) {
    double y;
    if (std::isnan(u0) || std::isnan(u1)) {
        y = (std::numeric_limits<double>::quiet_NaN());
    } else if (std::isinf(u0) && std::isinf(u1)) {
        int tmp;
        int tmp_0;
        if (u0 > 0.0) {
            tmp = 1;
        } else {
            tmp = -1;
        }

        if (u1 > 0.0) {
            tmp_0 = 1;
        } else {
            tmp_0 = -1;
        }

        y = std::atan2(static_cast<double>(tmp), static_cast<double>(tmp_0));
    } else if (u1 == 0.0) {
        if (u0 > 0.0) {
            y = 3.14159265358979323846 / 2.0;
        } else if (u0 < 0.0) {
            y = -(3.14159265358979323846 / 2.0);
        } else {
            y = 0.0;
        }
    } else {
        y = std::atan2(u0, u1);
    }

    return y;
}

////////////////////////////////////////////////////////////////////////////////
// This implementation is from code generated by Simulink Coder for the model:
// https://mathworks-my.sharepoint.com/:f:/p/sjayadev/EgoCqwY6gkZGs_KA6AI23LYBP7bTPd3jXw6_NTakm89CbQ?e=ilFed0
// The model compute the { latitude, longitude, altitude } of a point based on the WGS84 datum
// from the ECEF coordinate of that point

glm::vec3 mpProjectionUtil::GetECEF2LLA(double ecefX, double ecefY, double ecefZ) {
    double beta;
    double beta_tmp_tmp;
    double flat;
    double phi_tmp;
    double phi_tmp_0;
    double tmp;
    int    count;

    beta_tmp_tmp = std::sqrt(ecefX * ecefX + ecefY * ecefY);
    beta         = GetInverseTan(ecefZ, 0.99664718933525254 * beta_tmp_tmp);
    phi_tmp      = std::sin(beta);
    phi_tmp_0    = std::cos(beta);
    phi_tmp      = GetInverseTan(42841.311513313573 * phi_tmp * phi_tmp * phi_tmp +
                                     ecefZ,
                                 beta_tmp_tmp - 42697.672707179969 * phi_tmp_0 * phi_tmp_0 *
                                                    phi_tmp_0);
    phi_tmp_0    = GetInverseTan(0.99664718933525254 * std::sin(phi_tmp), std::cos(phi_tmp));
    count        = 0;
    while ((beta != phi_tmp_0) && (count < 5)) {
        beta      = phi_tmp_0;
        phi_tmp   = std::sin(phi_tmp_0);
        phi_tmp_0 = std::cos(phi_tmp_0);
        phi_tmp   = GetInverseTan(42841.311513313573 * phi_tmp * phi_tmp * phi_tmp +
                                      ecefZ,
                                  beta_tmp_tmp - 42697.672707179969 * phi_tmp_0 * phi_tmp_0 *
                                                     phi_tmp_0);
        phi_tmp_0 = GetInverseTan(0.99664718933525254 * std::sin(phi_tmp), std::cos(phi_tmp));
        count++;
    }

    flat      = std::abs(phi_tmp);
    phi_tmp_0 = phi_tmp;
    beta      = GetInverseTan(ecefY, ecefX);
    if (flat > 3.1415926535897931) {
        // rt_modd_snf in the generated code is basically the modulo operator. Since we already have
        // GetFloatingPointRemainder implemented, reusing that
        phi_tmp_0 = GetFloatingPointRemainder(phi_tmp + 3.1415926535897931, 6.2831853071795862) -
                    3.1415926535897931;
        flat = std::abs(phi_tmp_0);
    }

    if (flat > 1.5707963267948966) {
        beta += 3.1415926535897931;
        if (std::isnan(phi_tmp_0)) {
            tmp = (std::numeric_limits<double>::quiet_NaN());
        } else if (phi_tmp_0 < 0.0) {
            tmp = -1.0;
        } else {
            tmp = (phi_tmp_0 > 0.0);
        }

        phi_tmp_0 = (1.5707963267948966 - (flat - 1.5707963267948966)) * tmp;
    }

    if (std::abs(beta) > 3.1415926535897931) {
        beta = GetFloatingPointRemainder(beta, 6.2831853071795862);
        beta -= std::trunc(beta / 3.1415926535897931) * 6.2831853071795862;
    }

    tmp  = std::sin(phi_tmp);
    flat = 6.378137E+6 / std::sqrt(1.0 - tmp * tmp * 0.0066943799901413165);

    double altitude;
    double latitude;
    double longitude;

    altitude = ((flat * 0.0066943799901413165 * tmp + ecefZ) * tmp +
                beta_tmp_tmp * std::cos(phi_tmp)) -
               flat;

    latitude = phi_tmp_0 * 180.0 / 3.1415926535897931;

    longitude = beta * 180.0 / 3.1415926535897931;

    glm::vec3 lla(latitude, longitude, altitude);

    return lla;
}

////////////////////////////////////////////////////////////////////////////////

// namespace mpProjectionUtil {
// std::string mpProjection::ToWkt() const {
//     if (!SpatialReference) {
//         return std::string();
//     }
//
//     // char** wktOptions = CSLAddString(nullptr, "FORMAT=WKT2");
//     // wktOptions = CSLAddString(wktOptions, "MULTILINE=YES");
//     char* dest = nullptr;
//     SpatialReference->exportToWkt(&dest);
//     std::string qWkt(dest);
//     CPLFree(dest);
//
//     return qWkt;
// }
//
//////////////////////////////////////////////////////////////////////////////////
//
// rrSP<const mpProjection> CreateFromProjectionString(const std::string& projectionString) {
//    // Early out if WKT is empty
//    rrThrowVerify((projectionString.length() == 0), "Attempted to create projection from empty string.");
//
//    rrSP<OGRSpatialReference> spatialReference;
//    spatialReference = SpatialReferenceFromString(projectionString);
//
//    return std::make_shared<const mpProjection>(spatialReference);
//}
//
//////////////////////////////////////////////////////////////////////////////////
//
// rrSP<const mpProjection> CreateFromEPSGCode(const int epsgCode) {
//    rrSP<OGRSpatialReference> spatialReference = std::make_shared<OGRSpatialReference>();
//
//    if (spatialReference->importFromEPSG(epsgCode) == OGRERR_NONE) {
//        return std::make_shared<const mpProjection>(spatialReference);
//    }
//
//    rrThrow("Failed to import from EPSG code.");
//}
//
//////////////////////////////////////////////////////////////////////////////////
//
// rrSP<OGRSpatialReference> SpatialReferenceFromString(const std::string& projectionStdString) {
//    rrSP<OGRSpatialReference> spatialReference;
//
//    // Here we'll attempt different types of import on the string and take the first one
//    // that validates successfully (needs to be able to transform into WGS84)
//
//    spatialReference = std::make_shared<OGRSpatialReference>();
//
//    // importFromWkt
//    const char* charStr = projectionStdString.c_str();
//    if (spatialReference->importFromWkt(charStr) == OGRERR_NONE) {
//        return spatialReference;
//    }
//
//    // importFromWkt changes charStr to point to the remaining "unused" input after call, reset
//    charStr = projectionStdString.c_str();
//    if (spatialReference->importFromProj4(charStr) == OGRERR_NONE) {
//        return spatialReference;
//    }
//
//    rrThrow("Unable to import projection string.");
//}
//
//////////////////////////////////////////////////////////////////////////////////
//
// rrSP<const mpProjection> GetStandardLatLong() {
//    auto spatialReference = std::make_shared<OGRSpatialReference>();
//    rrThrowVerify(spatialReference->importFromEPSG(eEpsgWgs84) == 0, "Unable to import EPSG for standard lat long.");
//    rrSP<const mpProjection> standardLatLong = std::make_shared<const mpProjection>(spatialReference);
//
//    return standardLatLong;
//}
//
//////////////////////////////////////////////////////////////////////////////////
//
// mpProjectionTransform::~mpProjectionTransform() {
//    OGRCoordinateTransformation::DestroyCT(CoordinateTransform);
//    OGRCoordinateTransformation::DestroyCT(ReverseCoordinateTransform);
//}
//
//////////////////////////////////////////////////////////////////////////////////
//
// mpProjectionTransform::mpProjectionTransform(const mpProjection& source, const mpProjection& dest) {
//    // Safe - CreateCoordinateTransform takes non-const but does not modify.
//    OGRSpatialReference* nonConstSource = const_cast<OGRSpatialReference*>(source.GetSpatialReference().get());
//    OGRSpatialReference* nonConstDest   = const_cast<OGRSpatialReference*>(dest.GetSpatialReference().get());
//
//    CoordinateTransform = OGRCreateCoordinateTransformation(nonConstSource, nonConstDest);
//    rrThrowVerify(CoordinateTransform, "Coordinate Transform creation failed.");
//    ReverseCoordinateTransform = OGRCreateCoordinateTransformation(nonConstDest, nonConstSource);
//    rrThrowVerify(ReverseCoordinateTransform, "Reverse Coordinate Transform creation failed.");
//}
//
//////////////////////////////////////////////////////////////////////////////////
//
// void mpProjectionTransform::Transform(glm::dvec3& inoutSourcePoint, bool reverse) const {
//    auto transform = reverse ? ReverseCoordinateTransform : CoordinateTransform;
//    rrThrowVerify(transform->Transform(1, &inoutSourcePoint.x, &inoutSourcePoint.y, &inoutSourcePoint.z), "Coordinate transformation failed.");
//}
//
//} // namespace mpProjectionUtil

} // namespace rrProtoGrpc
